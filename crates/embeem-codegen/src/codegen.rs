//! C code generator for Embeem.

use alloc::format;
use alloc::string::{String, ToString};
use alloc::vec::Vec;

use embeem_ast::{
    BinaryOp, Block, ConstDecl, ElseBlock, Expression, Function, Literal, OpKind,
    PrimitiveType, Program, RangeDirection, Statement, Type, TypeContext, UnaryOp,
    infer_expression_type,
};

/// Code generation error.
#[derive(Clone, Debug, PartialEq)]
pub struct CodegenError {
    pub message: String,
}

impl CodegenError {
    pub fn new(msg: &str) -> Self {
        Self {
            message: msg.to_string(),
        }
    }
}

/// Options for C code generation.
#[derive(Clone, Debug, Default)]
pub struct CodegenOptions {
    /// Use GCC statement expressions `({ ... })` for block expressions and complex if expressions.
    /// This is a GCC extension that allows embedding statements inside expressions.
    /// When enabled, complex control flow can be inlined as expressions.
    /// When disabled, such constructs may produce errors or require restructuring.
    pub use_gcc_statement_exprs: bool,
}

impl CodegenOptions {
    /// Create default options (standard C, no extensions).
    pub fn new() -> Self {
        Self::default()
    }

    /// Enable GCC statement expressions.
    pub fn with_gcc_extensions(mut self) -> Self {
        self.use_gcc_statement_exprs = true;
        self
    }
}

/// C code generator.
pub struct CCodegen {
    output: String,
    indent: usize,
    temp_counter: usize,
    options: CodegenOptions,
    type_ctx: TypeContext,
}

impl CCodegen {
    /// Create a new code generator with default options.
    pub fn new() -> Self {
        Self::with_options(CodegenOptions::default())
    }

    /// Create a new code generator with the specified options.
    pub fn with_options(options: CodegenOptions) -> Self {
        Self {
            output: String::new(),
            indent: 0,
            temp_counter: 0,
            options,
            type_ctx: TypeContext::new(),
        }
    }

    /// Generate C code from an Embeem program.
    pub fn generate(&mut self, program: &Program) -> Result<String, CodegenError> {
        self.output.clear();
        self.type_ctx = TypeContext::from_program(program);
        self.temp_counter = 0;

        // Generate header
        self.emit_header();

        // Generate constants
        for constant in &program.constants {
            self.emit_const(constant)?;
        }
        if !program.constants.is_empty() {
            self.emit_line("");
        }

        // Generate function declarations
        for function in &program.functions {
            self.emit_function_decl(function)?;
        }
        if !program.functions.is_empty() {
            self.emit_line("");
        }

        // Generate function definitions
        for function in &program.functions {
            self.emit_function(function)?;
            self.emit_line("");
        }

        Ok(self.output.clone())
    }

    fn emit_header(&mut self) {
        self.emit_line("/* Generated by Embeem compiler */");
        if self.options.use_gcc_statement_exprs {
            self.emit_line("/* Using GCC statement expressions */");
        }
        self.emit_line("#include <stdint.h>");
        self.emit_line("#include <stdbool.h>");
        self.emit_line("");
        self.emit_line("/* Platform-specific operation declarations */");
        self.emit_line("/* These should be provided by the target platform */");
        self.emit_line("");
    }

    fn emit_const(&mut self, constant: &ConstDecl) -> Result<(), CodegenError> {
        let _c_type = self.type_to_c(&constant.ty);
        let value = self.expr_to_c(&constant.value)?;
        self.emit_line(&format!("#define {} ({})", constant.name, value));
        Ok(())
    }

    fn emit_function_decl(&mut self, function: &Function) -> Result<(), CodegenError> {
        let return_type = match &function.return_type {
            Some(ty) => self.type_to_c(ty),
            None => "void".to_string(),
        };

        let params = function
            .params
            .iter()
            .map(|p| format!("{} {}", self.type_to_c(&p.ty), p.name))
            .collect::<Vec<_>>()
            .join(", ");

        let params = if params.is_empty() {
            "void".to_string()
        } else {
            params
        };

        self.emit_line(&format!("{} {}({});", return_type, function.name, params));
        Ok(())
    }

    fn emit_function(&mut self, function: &Function) -> Result<(), CodegenError> {
        // Save the current type context and add function parameters
        let saved_ctx = self.type_ctx.clone();
        for param in &function.params {
            self.type_ctx.add_variable(param.name.clone(), param.ty.clone());
        }

        let return_type = match &function.return_type {
            Some(ty) => self.type_to_c(ty),
            None => "void".to_string(),
        };

        let params = function
            .params
            .iter()
            .map(|p| format!("{} {}", self.type_to_c(&p.ty), p.name))
            .collect::<Vec<_>>()
            .join(", ");

        let params = if params.is_empty() {
            "void".to_string()
        } else {
            params
        };

        self.emit_line(&format!("{} {}({}) {{", return_type, function.name, params));
        self.indent += 1;

        self.emit_block(&function.body, function.return_type.is_some())?;

        self.indent -= 1;
        self.emit_line("}");

        // Restore the type context
        self.type_ctx = saved_ctx;
        Ok(())
    }

    fn emit_block(&mut self, block: &Block, has_return: bool) -> Result<(), CodegenError> {
        for stmt in &block.statements {
            self.emit_statement(stmt)?;
        }

        if let Some(result) = &block.result {
            if has_return {
                let expr = self.expr_to_c(result)?;
                self.emit_line(&format!("return {};", expr));
            } else {
                let expr = self.expr_to_c(result)?;
                self.emit_line(&format!("{};", expr));
            }
        }

        Ok(())
    }

    fn emit_statement(&mut self, stmt: &Statement) -> Result<(), CodegenError> {
        match stmt {
            Statement::Let {
                name,
                mutable: _,
                ty,
                value,
            } => {
                // Use explicit type if provided, otherwise infer the type
                let inferred_ty = ty.as_ref().cloned().or_else(|| infer_expression_type(value, &self.type_ctx));
                let c_type = inferred_ty
                    .as_ref()
                    .map(|t| self.type_to_c(t))
                    .unwrap_or_else(|| "uint64_t".to_string());
                
                // Add the variable to the type context for future inference
                if let Some(var_ty) = inferred_ty {
                    self.type_ctx.add_variable(name.clone(), var_ty);
                }
                
                let expr = self.expr_to_c(value)?;
                self.emit_line(&format!("{} {} = {};", c_type, name, expr));
            }

            Statement::Assign { target, value } => {
                let expr = self.expr_to_c(value)?;
                self.emit_line(&format!("{} = {};", target, expr));
            }

            Statement::Expr(expr) => {
                let c_expr = self.expr_to_c(expr)?;
                self.emit_line(&format!("{};", c_expr));
            }

            Statement::If {
                condition,
                then_block,
                else_block,
            } => {
                let cond = self.expr_to_c(condition)?;
                self.emit_line(&format!("if ({}) {{", cond));
                self.indent += 1;
                self.emit_block(then_block, false)?;
                self.indent -= 1;

                match else_block {
                    Some(ElseBlock::Block(blk)) => {
                        self.emit_line("} else {");
                        self.indent += 1;
                        self.emit_block(blk, false)?;
                        self.indent -= 1;
                        self.emit_line("}");
                    }
                    Some(ElseBlock::ElseIf(stmt)) => {
                        self.emit("} else ");
                        self.emit_statement(stmt)?;
                    }
                    None => {
                        self.emit_line("}");
                    }
                }
            }

            Statement::For {
                variable,
                start,
                end,
                direction,
                body,
            } => {
                let start_expr = self.expr_to_c(start)?;
                let end_expr = self.expr_to_c(end)?;

                let (cond, update) = match direction {
                    RangeDirection::To => (
                        format!("{} <= {}", variable, end_expr),
                        format!("{}++", variable),
                    ),
                    RangeDirection::DownTo => (
                        format!("{} >= {}", variable, end_expr),
                        format!("{}--", variable),
                    ),
                };

                self.emit_line(&format!(
                    "for (int64_t {} = {}; {}; {}) {{",
                    variable, start_expr, cond, update
                ));
                self.indent += 1;
                self.emit_block(body, false)?;
                self.indent -= 1;
                self.emit_line("}");
            }

            Statement::Repeat { count, body } => {
                let count_expr = self.expr_to_c(count)?;
                let loop_var = self.fresh_temp();
                self.emit_line(&format!(
                    "for (uint64_t {} = 0; {} < {}; {}++) {{",
                    loop_var, loop_var, count_expr, loop_var
                ));
                self.indent += 1;
                self.emit_block(body, false)?;
                self.indent -= 1;
                self.emit_line("}");
            }

            Statement::While {
                condition,
                max_iterations,
                body,
            } => {
                let cond = self.expr_to_c(condition)?;
                let max = self.expr_to_c(max_iterations)?;
                let counter = self.fresh_temp();
                self.emit_line(&format!("uint64_t {} = 0;", counter));
                self.emit_line(&format!(
                    "while (({}) && ({} < {})) {{",
                    cond, counter, max
                ));
                self.indent += 1;
                self.emit_block(body, false)?;
                self.emit_line(&format!("{}++;", counter));
                self.indent -= 1;
                self.emit_line("}");
            }
        }

        Ok(())
    }

    fn expr_to_c(&mut self, expr: &Expression) -> Result<String, CodegenError> {
        match expr {
            Expression::Literal(lit) => match lit {
                Literal::Integer(n) => Ok(format!("{}ULL", n)),
                Literal::Float(f) => Ok(format!("{}", f)),
                Literal::Bool(b) => Ok(if *b { "1".to_string() } else { "0".to_string() }),
            },

            Expression::Identifier(name) => Ok(name.clone()),

            Expression::Binary { op, left, right } => {
                let l = self.expr_to_c(left)?;
                let r = self.expr_to_c(right)?;
                let op_str = match op {
                    BinaryOp::Add => "+",
                    BinaryOp::Sub => "-",
                    BinaryOp::Mul => "*",
                    BinaryOp::Div => "/",
                    BinaryOp::Mod => "%",
                    BinaryOp::BitAnd => "&",
                    BinaryOp::BitOr => "|",
                    BinaryOp::BitXor => "^",
                    BinaryOp::Shl => "<<",
                    BinaryOp::Shr => ">>",
                    BinaryOp::LogicalShr => ">>",
                    BinaryOp::Eq => "==",
                    BinaryOp::Ne => "!=",
                    BinaryOp::Lt => "<",
                    BinaryOp::Le => "<=",
                    BinaryOp::Gt => ">",
                    BinaryOp::Ge => ">=",
                    BinaryOp::And => "&&",
                    BinaryOp::Or => "||",
                };
                Ok(format!("({} {} {})", l, op_str, r))
            }

            Expression::Unary { op, operand } => {
                let o = self.expr_to_c(operand)?;
                let op_str = match op {
                    UnaryOp::Neg => "-",
                    UnaryOp::BitNot => "~",
                    UnaryOp::Not => "!",
                };
                Ok(format!("({}{})", op_str, o))
            }

            Expression::If {
                condition,
                then_branch,
                else_branch,
            } => {
                let cond = self.expr_to_c(condition)?;
                // For simple expressions, use ternary operator
                if then_branch.statements.is_empty() && else_branch.statements.is_empty() {
                    if let (Some(then_expr), Some(else_expr)) =
                        (&then_branch.result, &else_branch.result)
                    {
                        let t = self.expr_to_c(then_expr)?;
                        let e = self.expr_to_c(else_expr)?;
                        return Ok(format!("({} ? {} : {})", cond, t, e));
                    }
                }
                // For complex blocks, use GCC statement expressions if enabled
                if self.options.use_gcc_statement_exprs {
                    self.emit_if_expr_gcc(condition, then_branch, else_branch)
                } else {
                    Err(CodegenError::new(
                        "complex if expressions not supported in expression context (enable GCC extensions)",
                    ))
                }
            }

            Expression::Operation { kind, args } => {
                self.emit_operation(*kind, args)
            }

            Expression::Call { function, args } => {
                let arg_strs: Result<Vec<_>, _> =
                    args.iter().map(|a| self.expr_to_c(a)).collect();
                let arg_strs = arg_strs?;
                Ok(format!("{}({})", function, arg_strs.join(", ")))
            }

            Expression::Block(blk) => {
                if self.options.use_gcc_statement_exprs {
                    self.emit_block_expr_gcc(blk)
                } else {
                    Err(CodegenError::new("block expressions not supported in expression context (enable GCC extensions)"))
                }
            }

            Expression::Index { array, index } => {
                let arr = self.expr_to_c(array)?;
                let idx = self.expr_to_c(index)?;
                Ok(format!("{}[{}]", arr, idx))
            }

            Expression::Array(elements) => {
                let elem_strs: Result<Vec<_>, _> =
                    elements.iter().map(|e| self.expr_to_c(e)).collect();
                let elem_strs = elem_strs?;
                Ok(format!("{{{}}}", elem_strs.join(", ")))
            }

            Expression::Cast { value, ty } => {
                let v = self.expr_to_c(value)?;
                let c_type = self.type_to_c(ty);
                Ok(format!("(({}){})", c_type, v))
            }
        }
    }

    fn emit_operation(&mut self, kind: OpKind, args: &[Expression]) -> Result<String, CodegenError> {
        let arg_strs: Result<Vec<_>, _> = args.iter().map(|a| self.expr_to_c(a)).collect();
        let arg_strs = arg_strs?;

        // Generate the operation call
        let op_name = self.op_kind_to_c_name(kind);
        
        // Some operations map directly to C operators
        match kind {
            OpKind::Add if arg_strs.len() == 2 => {
                Ok(format!("({} + {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Sub if arg_strs.len() == 2 => {
                Ok(format!("({} - {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Mul if arg_strs.len() == 2 => {
                Ok(format!("({} * {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Div if arg_strs.len() == 2 => {
                // Division by zero returns zero in Embeem
                Ok(format!("({1} != 0 ? ({0}) / ({1}) : 0)", arg_strs[0], arg_strs[1]))
            }
            OpKind::Mod if arg_strs.len() == 2 => {
                Ok(format!("({1} != 0 ? ({0}) % ({1}) : 0)", arg_strs[0], arg_strs[1]))
            }
            OpKind::Inc if arg_strs.len() == 1 => {
                Ok(format!("({} + 1)", arg_strs[0]))
            }
            OpKind::Dec if arg_strs.len() == 1 => {
                Ok(format!("({} - 1)", arg_strs[0]))
            }
            OpKind::Neg if arg_strs.len() == 1 => {
                Ok(format!("(-{})", arg_strs[0]))
            }
            OpKind::Abs if arg_strs.len() == 1 => {
                Ok(format!("(({0}) < 0 ? -({0}) : ({0}))", arg_strs[0]))
            }
            OpKind::And if arg_strs.len() == 2 => {
                Ok(format!("({} & {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Or if arg_strs.len() == 2 => {
                Ok(format!("({} | {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Xor if arg_strs.len() == 2 => {
                Ok(format!("({} ^ {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Not if arg_strs.len() == 1 => {
                Ok(format!("(~{})", arg_strs[0]))
            }
            OpKind::Shl if arg_strs.len() == 2 => {
                Ok(format!("({} << {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Shr if arg_strs.len() == 2 => {
                Ok(format!("({} >> {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Eq if arg_strs.len() == 2 => {
                Ok(format!("({} == {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Ne if arg_strs.len() == 2 => {
                Ok(format!("({} != {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Lt if arg_strs.len() == 2 => {
                Ok(format!("({} < {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Le if arg_strs.len() == 2 => {
                Ok(format!("({} <= {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Gt if arg_strs.len() == 2 => {
                Ok(format!("({} > {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Ge if arg_strs.len() == 2 => {
                Ok(format!("({} >= {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Nop => Ok("((void)0)".to_string()),
            _ => {
                // For other operations, generate a function call
                Ok(format!("{}({})", op_name, arg_strs.join(", ")))
            }
        }
    }

    fn op_kind_to_c_name(&self, kind: OpKind) -> &'static str {
        match kind {
            OpKind::Add => "embeem_add",
            OpKind::Sub => "embeem_sub",
            OpKind::Mul => "embeem_mul",
            OpKind::Div => "embeem_div",
            OpKind::Mod => "embeem_mod",
            OpKind::Inc => "embeem_inc",
            OpKind::Dec => "embeem_dec",
            OpKind::Neg => "embeem_neg",
            OpKind::Abs => "embeem_abs",
            OpKind::And => "embeem_and",
            OpKind::Or => "embeem_or",
            OpKind::Xor => "embeem_xor",
            OpKind::Not => "embeem_not",
            OpKind::Shl => "embeem_shl",
            OpKind::Shr => "embeem_shr",
            OpKind::Sar => "embeem_sar",
            OpKind::Rol => "embeem_rol",
            OpKind::Ror => "embeem_ror",
            OpKind::Cmp => "embeem_cmp",
            OpKind::Test => "embeem_test",
            OpKind::Eq => "embeem_eq",
            OpKind::Ne => "embeem_ne",
            OpKind::Lt => "embeem_lt",
            OpKind::Le => "embeem_le",
            OpKind::Gt => "embeem_gt",
            OpKind::Ge => "embeem_ge",
            OpKind::Nop => "embeem_nop",
            OpKind::Halt => "embeem_halt",
            OpKind::Sleep => "embeem_sleep",
            OpKind::SetBit => "embeem_set_bit",
            OpKind::ClearBit => "embeem_clear_bit",
            OpKind::ToggleBit => "embeem_toggle_bit",
            OpKind::TestBit => "embeem_test_bit",
            OpKind::CountOnes => "embeem_count_ones",
            OpKind::CountZeros => "embeem_count_zeros",
            OpKind::FindFirstSet => "embeem_find_first_set",
            OpKind::FindFirstZero => "embeem_find_first_zero",
            OpKind::FAdd => "embeem_fadd",
            OpKind::FSub => "embeem_fsub",
            OpKind::FMul => "embeem_fmul",
            OpKind::FDiv => "embeem_fdiv",
            OpKind::FSqrt => "embeem_fsqrt",
            OpKind::FAbs => "embeem_fabs",
            OpKind::FCmp => "embeem_fcmp",
            OpKind::GpioRead => "GPIO_READ",
            OpKind::GpioWrite => "GPIO_WRITE",
            OpKind::GpioToggle => "GPIO_TOGGLE",
            OpKind::GpioSetMode => "GPIO_SET_MODE",
            OpKind::GpioReadPort => "GPIO_READ_PORT",
            OpKind::GpioWritePort => "GPIO_WRITE_PORT",
            OpKind::AdcRead => "ADC_READ",
            OpKind::AdcStartConversion => "ADC_START_CONVERSION",
            OpKind::AdcReadMulti => "ADC_READ_MULTI",
            OpKind::DacWrite => "DAC_WRITE",
            OpKind::AdcSetResolution => "ADC_SET_RESOLUTION",
            OpKind::AdcSetReference => "ADC_SET_REFERENCE",
            OpKind::PwmStart => "PWM_START",
            OpKind::PwmStop => "PWM_STOP",
            OpKind::PwmSetDutyCycle => "PWM_SET_DUTY_CYCLE",
            OpKind::PwmSetFrequency => "PWM_SET_FREQUENCY",
            OpKind::PwmSetPulseWidth => "PWM_SET_PULSE_WIDTH",
            OpKind::TimerStart => "TIMER_START",
            OpKind::TimerStop => "TIMER_STOP",
            OpKind::TimerReset => "TIMER_RESET",
            OpKind::TimerRead => "TIMER_READ",
            OpKind::TimerSetPeriod => "TIMER_SET_PERIOD",
            OpKind::TimerSetCompare => "TIMER_SET_COMPARE",
            OpKind::GetMillis => "GET_MILLIS",
            OpKind::GetMicros => "GET_MICROS",
            OpKind::DelayMs => "DELAY_MS",
            OpKind::DelayUs => "DELAY_US",
            OpKind::UartInit => "UART_INIT",
            OpKind::UartWriteByte => "UART_WRITE_BYTE",
            OpKind::UartWriteBuffer => "UART_WRITE_BUFFER",
            OpKind::UartReadByte => "UART_READ_BYTE",
            OpKind::UartReadBuffer => "UART_READ_BUFFER",
            OpKind::UartAvailable => "UART_AVAILABLE",
            OpKind::UartFlush => "UART_FLUSH",
            OpKind::UartSetBaudRate => "UART_SET_BAUD_RATE",
            OpKind::SpiInit => "SPI_INIT",
            OpKind::SpiTransfer => "SPI_TRANSFER",
            OpKind::SpiTransferBuffer => "SPI_TRANSFER_BUFFER",
            OpKind::SpiSetMode => "SPI_SET_MODE",
            OpKind::SpiSetClock => "SPI_SET_CLOCK",
            OpKind::SpiSetBitOrder => "SPI_SET_BIT_ORDER",
            OpKind::SpiBeginTransaction => "SPI_BEGIN_TRANSACTION",
            OpKind::SpiEndTransaction => "SPI_END_TRANSACTION",
            OpKind::I2cInit => "I2C_INIT",
            OpKind::I2cStart => "I2C_START",
            OpKind::I2cStop => "I2C_STOP",
            OpKind::I2cWrite => "I2C_WRITE",
            OpKind::I2cRead => "I2C_READ",
            OpKind::I2cWriteTo => "I2C_WRITE_TO",
            OpKind::I2cReadFrom => "I2C_READ_FROM",
            OpKind::I2cSetClock => "I2C_SET_CLOCK",
            OpKind::I2cScan => "I2C_SCAN",
            OpKind::CanInit => "CAN_INIT",
            OpKind::CanSend => "CAN_SEND",
            OpKind::CanReceive => "CAN_RECEIVE",
            OpKind::CanSetFilter => "CAN_SET_FILTER",
            OpKind::CanSetBitrate => "CAN_SET_BITRATE",
            OpKind::UsbInit => "USB_INIT",
            OpKind::UsbConnect => "USB_CONNECT",
            OpKind::UsbDisconnect => "USB_DISCONNECT",
            OpKind::UsbWrite => "USB_WRITE",
            OpKind::UsbRead => "USB_READ",
            OpKind::UsbAvailable => "USB_AVAILABLE",
            OpKind::WdtEnable => "WDT_ENABLE",
            OpKind::WdtDisable => "WDT_DISABLE",
            OpKind::WdtReset => "WDT_RESET",
            OpKind::WdtSetTimeout => "WDT_SET_TIMEOUT",
            OpKind::DmaInit => "DMA_INIT",
            OpKind::DmaStart => "DMA_START",
            OpKind::DmaStop => "DMA_STOP",
            OpKind::DmaConfig => "DMA_CONFIG",
            OpKind::DmaSetSource => "DMA_SET_SOURCE",
            OpKind::DmaSetDestination => "DMA_SET_DESTINATION",
            OpKind::EepromRead => "EEPROM_READ",
            OpKind::EepromWrite => "EEPROM_WRITE",
            OpKind::EepromUpdate => "EEPROM_UPDATE",
            OpKind::FlashRead => "FLASH_READ",
            OpKind::FlashWrite => "FLASH_WRITE",
            OpKind::FlashErase => "FLASH_ERASE",
            OpKind::SetPowerMode => "SET_POWER_MODE",
            OpKind::DisablePeripheral => "DISABLE_PERIPHERAL",
            OpKind::EnablePeripheral => "ENABLE_PERIPHERAL",
            OpKind::SetClockSpeed => "SET_CLOCK_SPEED",
            OpKind::EnterStandby => "ENTER_STANDBY",
            OpKind::EnterDeepSleep => "ENTER_DEEP_SLEEP",
            OpKind::RtcInit => "RTC_INIT",
            OpKind::RtcSetTime => "RTC_SET_TIME",
            OpKind::RtcGetTime => "RTC_GET_TIME",
            OpKind::RtcSetAlarm => "RTC_SET_ALARM",
            OpKind::RtcSetCalendar => "RTC_SET_CALENDAR",
        }
    }

    /// Emit a block expression using GCC statement expression syntax: `({ ... })`
    fn emit_block_expr_gcc(&mut self, block: &Block) -> Result<String, CodegenError> {
        let mut result = String::from("({ ");
        
        // Emit statements inline
        for stmt in &block.statements {
            let stmt_str = self.emit_statement_to_string(stmt)?;
            result.push_str(&stmt_str);
            result.push(' ');
        }
        
        // Emit result expression if present
        if let Some(ref expr) = block.result {
            let expr_str = self.expr_to_c(expr)?;
            result.push_str(&expr_str);
            result.push_str("; ");
        }
        
        result.push_str("})");
        Ok(result)
    }

    /// Emit an if expression using GCC statement expression syntax.
    fn emit_if_expr_gcc(
        &mut self,
        condition: &Expression,
        then_branch: &Block,
        else_branch: &Block,
    ) -> Result<String, CodegenError> {
        let cond = self.expr_to_c(condition)?;
        let result_var = self.fresh_temp();
        
        let mut result = format!("({{ uint64_t {}; if ({}) {{ ", result_var, cond);
        
        // Then branch
        for stmt in &then_branch.statements {
            let stmt_str = self.emit_statement_to_string(stmt)?;
            result.push_str(&stmt_str);
            result.push(' ');
        }
        if let Some(ref expr) = then_branch.result {
            let expr_str = self.expr_to_c(expr)?;
            result.push_str(&format!("{} = {}; ", result_var, expr_str));
        }
        
        result.push_str("} else { ");
        
        // Else branch
        for stmt in &else_branch.statements {
            let stmt_str = self.emit_statement_to_string(stmt)?;
            result.push_str(&stmt_str);
            result.push(' ');
        }
        if let Some(ref expr) = else_branch.result {
            let expr_str = self.expr_to_c(expr)?;
            result.push_str(&format!("{} = {}; ", result_var, expr_str));
        }
        
        result.push_str(&format!("}} {}; }})", result_var));
        Ok(result)
    }

    /// Emit a statement to a string (for use in GCC statement expressions).
    fn emit_statement_to_string(&mut self, stmt: &Statement) -> Result<String, CodegenError> {
        match stmt {
            Statement::Let {
                name,
                mutable: _,
                ty,
                value,
            } => {
                let c_type = ty
                    .as_ref()
                    .map(|t| self.type_to_c(t))
                    .unwrap_or_else(|| "uint64_t".to_string());
                let expr = self.expr_to_c(value)?;
                Ok(format!("{} {} = {};", c_type, name, expr))
            }

            Statement::Assign { target, value } => {
                let expr = self.expr_to_c(value)?;
                Ok(format!("{} = {};", target, expr))
            }

            Statement::Expr(expr) => {
                let c_expr = self.expr_to_c(expr)?;
                Ok(format!("{};", c_expr))
            }

            Statement::If {
                condition,
                then_block,
                else_block,
            } => {
                let cond = self.expr_to_c(condition)?;
                let mut result = format!("if ({}) {{ ", cond);
                
                for s in &then_block.statements {
                    let s_str = self.emit_statement_to_string(s)?;
                    result.push_str(&s_str);
                    result.push(' ');
                }
                if let Some(ref expr) = then_block.result {
                    let expr_str = self.expr_to_c(expr)?;
                    result.push_str(&expr_str);
                    result.push_str("; ");
                }
                
                match else_block {
                    Some(ElseBlock::Block(blk)) => {
                        result.push_str("} else { ");
                        for s in &blk.statements {
                            let s_str = self.emit_statement_to_string(s)?;
                            result.push_str(&s_str);
                            result.push(' ');
                        }
                        if let Some(ref expr) = blk.result {
                            let expr_str = self.expr_to_c(expr)?;
                            result.push_str(&expr_str);
                            result.push_str("; ");
                        }
                        result.push('}');
                    }
                    Some(ElseBlock::ElseIf(stmt)) => {
                        result.push_str("} else ");
                        let stmt_str = self.emit_statement_to_string(stmt)?;
                        result.push_str(&stmt_str);
                    }
                    None => {
                        result.push('}');
                    }
                }
                
                Ok(result)
            }

            Statement::For {
                variable,
                start,
                end,
                direction,
                body,
            } => {
                let start_expr = self.expr_to_c(start)?;
                let end_expr = self.expr_to_c(end)?;

                let (cond, update) = match direction {
                    RangeDirection::To => (
                        format!("{} <= {}", variable, end_expr),
                        format!("{}++", variable),
                    ),
                    RangeDirection::DownTo => (
                        format!("{} >= {}", variable, end_expr),
                        format!("{}--", variable),
                    ),
                };

                let mut result = format!(
                    "for (int64_t {} = {}; {}; {}) {{ ",
                    variable, start_expr, cond, update
                );
                
                for s in &body.statements {
                    let s_str = self.emit_statement_to_string(s)?;
                    result.push_str(&s_str);
                    result.push(' ');
                }
                if let Some(ref expr) = body.result {
                    let expr_str = self.expr_to_c(expr)?;
                    result.push_str(&expr_str);
                    result.push_str("; ");
                }
                
                result.push('}');
                Ok(result)
            }

            Statement::Repeat { count, body } => {
                let count_expr = self.expr_to_c(count)?;
                let loop_var = self.fresh_temp();
                
                let mut result = format!(
                    "for (uint64_t {} = 0; {} < {}; {}++) {{ ",
                    loop_var, loop_var, count_expr, loop_var
                );
                
                for s in &body.statements {
                    let s_str = self.emit_statement_to_string(s)?;
                    result.push_str(&s_str);
                    result.push(' ');
                }
                if let Some(ref expr) = body.result {
                    let expr_str = self.expr_to_c(expr)?;
                    result.push_str(&expr_str);
                    result.push_str("; ");
                }
                
                result.push('}');
                Ok(result)
            }

            Statement::While {
                condition,
                max_iterations,
                body,
            } => {
                let cond = self.expr_to_c(condition)?;
                let max = self.expr_to_c(max_iterations)?;
                let counter = self.fresh_temp();
                
                let mut result = format!("uint64_t {} = 0; ", counter);
                result.push_str(&format!(
                    "while (({}) && ({} < {})) {{ ",
                    cond, counter, max
                ));
                
                for s in &body.statements {
                    let s_str = self.emit_statement_to_string(s)?;
                    result.push_str(&s_str);
                    result.push(' ');
                }
                if let Some(ref expr) = body.result {
                    let expr_str = self.expr_to_c(expr)?;
                    result.push_str(&expr_str);
                    result.push_str("; ");
                }
                
                result.push_str(&format!("{}++; }}", counter));
                Ok(result)
            }
        }
    }

    fn type_to_c(&self, ty: &Type) -> String {
        match ty {
            Type::Primitive(prim) => match prim {
                PrimitiveType::U8 => "uint8_t".to_string(),
                PrimitiveType::U16 => "uint16_t".to_string(),
                PrimitiveType::U32 => "uint32_t".to_string(),
                PrimitiveType::U64 => "uint64_t".to_string(),
                PrimitiveType::I8 => "int8_t".to_string(),
                PrimitiveType::I16 => "int16_t".to_string(),
                PrimitiveType::I32 => "int32_t".to_string(),
                PrimitiveType::I64 => "int64_t".to_string(),
                PrimitiveType::F32 => "float".to_string(),
                PrimitiveType::F64 => "double".to_string(),
                PrimitiveType::Bool => "bool".to_string(),
            },
            Type::Array(elem, size) => {
                format!("{}[{}]", self.type_to_c(elem), size)
            }
            Type::Tuple(types) => {
                // C doesn't have tuples, use a struct
                format!("struct {{ {} }}", 
                    types.iter().enumerate()
                        .map(|(i, t)| format!("{} _{}", self.type_to_c(t), i))
                        .collect::<Vec<_>>()
                        .join("; "))
            }
        }
    }

    fn fresh_temp(&mut self) -> String {
        let name = format!("_tmp{}", self.temp_counter);
        self.temp_counter += 1;
        name
    }

    fn emit(&mut self, s: &str) {
        self.output.push_str(s);
    }

    fn emit_line(&mut self, s: &str) {
        for _ in 0..self.indent {
            self.output.push_str("    ");
        }
        self.output.push_str(s);
        self.output.push('\n');
    }
}

impl Default for CCodegen {
    fn default() -> Self {
        Self::new()
    }
}

/// Convenience function to compile an Embeem program to C (standard C, no extensions).
pub fn compile_to_c(program: &Program) -> Result<String, CodegenError> {
    let mut codegen = CCodegen::new();
    codegen.generate(program)
}

/// Convenience function to compile an Embeem program to C with specified options.
pub fn compile_to_c_with_options(program: &Program, options: CodegenOptions) -> Result<String, CodegenError> {
    let mut codegen = CCodegen::with_options(options);
    codegen.generate(program)
}

/// Convenience function to compile an Embeem program to C using GCC extensions.
/// This enables GCC statement expressions `({ ... })` for block and complex if expressions.
pub fn compile_to_c_gcc(program: &Program) -> Result<String, CodegenError> {
    let options = CodegenOptions::new().with_gcc_extensions();
    let mut codegen = CCodegen::with_options(options);
    codegen.generate(program)
}

#[cfg(test)]
mod tests {
    extern crate std;
    use super::*;
    use embeem_parser::parse_program;

    #[test]
    fn test_simple_program() {
        let src = r#"
            fn main() {
                GPIO_SET_MODE(13, 1);
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        assert!(c_code.contains("void main(void)"));
        assert!(c_code.contains("GPIO_SET_MODE"));
    }

    #[test]
    fn test_constants() {
        let src = r#"
            const LED_PIN: u8 = 13;
            fn main() {}
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        assert!(c_code.contains("#define LED_PIN"));
    }

    #[test]
    fn test_repeat_loop() {
        let src = r#"
            fn main() {
                repeat 10 {
                    DELAY_MS(100);
                }
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        assert!(c_code.contains("for"));
        assert!(c_code.contains("< 10"));
    }

    #[test]
    fn test_for_loop() {
        let src = r#"
            fn main() {
                for i in 0 to 9 {
                    GPIO_TOGGLE(i);
                }
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        assert!(c_code.contains("for"));
        assert!(c_code.contains("i++"));
    }

    #[test]
    fn test_if_statement() {
        let src = r#"
            fn main() {
                let x: u32 = 42;
                if x > 0 {
                    GPIO_WRITE(13, 1);
                } else {
                    GPIO_WRITE(13, 0);
                }
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        assert!(c_code.contains("if"));
        assert!(c_code.contains("else"));
    }

    #[test]
    fn test_gcc_statement_expressions_header() {
        let src = r#"
            fn main() {}
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c_gcc(&program).unwrap();
        assert!(c_code.contains("Using GCC statement expressions"));
    }

    #[test]
    fn test_gcc_block_expression() {
        let src = r#"
            fn get_value() -> u32 {
                let result = {
                    let x: u32 = 10;
                    x + 5
                };
                result
            }
        "#;
        let program = parse_program(src).unwrap();
        // Should fail without GCC extensions
        let result = compile_to_c(&program);
        assert!(result.is_err());
        
        // Should succeed with GCC extensions
        let c_code = compile_to_c_gcc(&program).unwrap();
        assert!(c_code.contains("({"));
        assert!(c_code.contains("})"));
    }

    #[test]
    fn test_gcc_complex_if_expression() {
        let src = r#"
            fn get_max(a: u32, b: u32) -> u32 {
                let result = if a > b {
                    let temp: u32 = a;
                    temp
                } else {
                    let temp: u32 = b;
                    temp
                };
                result
            }
        "#;
        let program = parse_program(src).unwrap();
        // Should fail without GCC extensions
        let result = compile_to_c(&program);
        assert!(result.is_err());
        
        // Should succeed with GCC extensions
        let c_code = compile_to_c_gcc(&program).unwrap();
        assert!(c_code.contains("({"));
    }

    #[test]
    fn test_simple_ternary_still_works() {
        // Simple if expressions should use ternary even without GCC extensions
        let src = r#"
            fn max_val(a: u32, b: u32) -> u32 {
                if a > b { a } else { b }
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        assert!(c_code.contains("?"), "Expected ternary operator '?', got:\n{}", c_code);
        assert!(c_code.contains(":"));
    }

    #[test]
    fn test_type_inference_for_let() {
        // Test that type inference works for let statements without explicit types
        let src = r#"
            fn main() {
                let x = 42;
                let y = true;
                let z = 3.14;
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        // x should be inferred as uint64_t (integer literal)
        assert!(c_code.contains("uint64_t x = "), "Expected uint64_t for integer literal, got:\n{}", c_code);
        // y should be inferred as bool
        assert!(c_code.contains("bool y = "), "Expected bool for boolean literal, got:\n{}", c_code);
        // z should be inferred as double (float literal)
        assert!(c_code.contains("double z = "), "Expected double for float literal, got:\n{}", c_code);
    }

    #[test]
    fn test_type_inference_comparison() {
        // Test that comparison results are inferred as bool
        let src = r#"
            fn test() {
                let x: u32 = 10;
                let y: u32 = 5;
                let is_greater = x > y;
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        // is_greater should be inferred as bool
        assert!(c_code.contains("bool is_greater = "), "Expected bool for comparison result, got:\n{}", c_code);
    }

    #[test]
    fn test_type_inference_from_variable() {
        // Test that a variable's type is inferred from another variable
        let src = r#"
            fn test() {
                let x: u16 = 100;
                let y = x;
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        // y should be inferred as uint16_t from x
        assert!(c_code.contains("uint16_t y = "), "Expected uint16_t for variable reference, got:\n{}", c_code);
    }
}
