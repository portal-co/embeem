//! C code generator for Embeem.

use alloc::format;
use alloc::string::{String, ToString};
use alloc::vec::Vec;

use embeem_ast::{
    BinaryOp, Block, ConstDecl, ElseBlock, Expression, Function, Literal, OpKind,
    PrimitiveType, Program, RangeDirection, Statement, Type, TypeContext, UnaryOp,
    infer_expression_type,
};

/// Code generation error.
#[derive(Clone, Debug, PartialEq)]
pub struct CodegenError {
    pub message: String,
}

impl CodegenError {
    pub fn new(msg: &str) -> Self {
        Self {
            message: msg.to_string(),
        }
    }
}

/// Options for C code generation.
#[derive(Clone, Debug)]
pub struct CodegenOptions {
    /// Use GCC statement expressions `({ ... })` for block expressions and complex if expressions.
    /// This is a GCC extension that allows embedding statements inside expressions.
    /// When enabled, complex control flow can be inlined as expressions.
    /// When disabled, such constructs may produce errors or require restructuring.
    pub use_gcc_statement_exprs: bool,
    /// Prefix for mangled function names to avoid symbol collisions.
    /// Default is "embeem_".
    pub mangle_prefix: String,
    /// Prefix for operation function names.
    /// Users can customize this to provide their own operation implementations.
    /// Default is "embeem_op_".
    pub op_prefix: String,
}

impl Default for CodegenOptions {
    fn default() -> Self {
        Self {
            use_gcc_statement_exprs: false,
            mangle_prefix: "embeem_".to_string(),
            op_prefix: "embeem_op_".to_string(),
        }
    }
}

impl CodegenOptions {
    /// Create default options (standard C, no extensions).
    pub fn new() -> Self {
        Self::default()
    }

    /// Enable GCC statement expressions.
    pub fn with_gcc_extensions(mut self) -> Self {
        self.use_gcc_statement_exprs = true;
        self
    }

    /// Set the function name mangling prefix.
    pub fn with_mangle_prefix(mut self, prefix: &str) -> Self {
        self.mangle_prefix = prefix.to_string();
        self
    }

    /// Set the operation function prefix for customizing operation implementations.
    pub fn with_op_prefix(mut self, prefix: &str) -> Self {
        self.op_prefix = prefix.to_string();
        self
    }
}

/// C code generator.
pub struct CCodegen {
    output: String,
    indent: usize,
    temp_counter: usize,
    options: CodegenOptions,
    type_ctx: TypeContext,
}

impl CCodegen {
    /// Create a new code generator with default options.
    pub fn new() -> Self {
        Self::with_options(CodegenOptions::default())
    }

    /// Create a new code generator with the specified options.
    pub fn with_options(options: CodegenOptions) -> Self {
        Self {
            output: String::new(),
            indent: 0,
            temp_counter: 0,
            options,
            type_ctx: TypeContext::new(),
        }
    }

    /// Generate C code from an Embeem program.
    pub fn generate(&mut self, program: &Program) -> Result<String, CodegenError> {
        self.output.clear();
        self.type_ctx = TypeContext::from_program(program);
        self.temp_counter = 0;

        // Generate header
        self.emit_header();

        // Generate constants
        for constant in &program.constants {
            self.emit_const(constant)?;
        }
        if !program.constants.is_empty() {
            self.emit_line("");
        }

        // Generate function declarations
        for function in &program.functions {
            self.emit_function_decl(function)?;
        }
        if !program.functions.is_empty() {
            self.emit_line("");
        }

        // Generate function definitions
        for function in &program.functions {
            self.emit_function(function)?;
            self.emit_line("");
        }

        Ok(self.output.clone())
    }

    fn emit_header(&mut self) {
        self.emit_line("/* Generated by Embeem compiler */");
        if self.options.use_gcc_statement_exprs {
            self.emit_line("/* Using GCC statement expressions */");
        }
        self.emit_line("#include <stdint.h>");
        self.emit_line("#include <stdbool.h>");
        self.emit_line("");
        
        // Generate static inline functions for operations with direct C equivalents
        self.emit_line("/* Inline implementations for operations with direct C equivalents */");
        self.emit_line("");
        
        // Arithmetic operations
        self.emit_inline_binop("add", "+");
        self.emit_inline_binop("sub", "-");
        self.emit_inline_binop("mul", "*");
        self.emit_line(&format!("static inline uint64_t {}div(uint64_t a, uint64_t b) {{ return b != 0 ? a / b : 0; }}", self.options.op_prefix));
        self.emit_line(&format!("static inline uint64_t {}mod(uint64_t a, uint64_t b) {{ return b != 0 ? a % b : 0; }}", self.options.op_prefix));
        self.emit_line(&format!("static inline uint64_t {}inc(uint64_t x) {{ return x + 1; }}", self.options.op_prefix));
        self.emit_line(&format!("static inline uint64_t {}dec(uint64_t x) {{ return x - 1; }}", self.options.op_prefix));
        self.emit_line(&format!("static inline int64_t {}neg(int64_t x) {{ return -x; }}", self.options.op_prefix));
        self.emit_line(&format!("static inline int64_t {}abs(int64_t x) {{ return x < 0 ? -x : x; }}", self.options.op_prefix));
        self.emit_line("");
        
        // Bitwise operations
        self.emit_inline_binop("and", "&");
        self.emit_inline_binop("or", "|");
        self.emit_inline_binop("xor", "^");
        self.emit_line(&format!("static inline uint64_t {}not(uint64_t x) {{ return ~x; }}", self.options.op_prefix));
        self.emit_line(&format!("static inline uint64_t {}shl(uint64_t x, uint64_t n) {{ return x << n; }}", self.options.op_prefix));
        self.emit_line(&format!("static inline uint64_t {}shr(uint64_t x, uint64_t n) {{ return x >> n; }}", self.options.op_prefix));
        self.emit_line(&format!("static inline int64_t {}sar(int64_t x, uint64_t n) {{ return x >> n; }}", self.options.op_prefix));
        self.emit_line(&format!("static inline uint64_t {}rol(uint64_t x, uint64_t n) {{ n &= 63; return (x << n) | (x >> (64 - n)); }}", self.options.op_prefix));
        self.emit_line(&format!("static inline uint64_t {}ror(uint64_t x, uint64_t n) {{ n &= 63; return (x >> n) | (x << (64 - n)); }}", self.options.op_prefix));
        self.emit_line("");
        
        // Comparison operations
        self.emit_line(&format!("static inline bool {}eq(uint64_t a, uint64_t b) {{ return a == b; }}", self.options.op_prefix));
        self.emit_line(&format!("static inline bool {}ne(uint64_t a, uint64_t b) {{ return a != b; }}", self.options.op_prefix));
        self.emit_line(&format!("static inline bool {}lt(uint64_t a, uint64_t b) {{ return a < b; }}", self.options.op_prefix));
        self.emit_line(&format!("static inline bool {}le(uint64_t a, uint64_t b) {{ return a <= b; }}", self.options.op_prefix));
        self.emit_line(&format!("static inline bool {}gt(uint64_t a, uint64_t b) {{ return a > b; }}", self.options.op_prefix));
        self.emit_line(&format!("static inline bool {}ge(uint64_t a, uint64_t b) {{ return a >= b; }}", self.options.op_prefix));
        self.emit_line(&format!("static inline int32_t {}cmp(uint64_t a, uint64_t b) {{ return a < b ? -1 : (a > b ? 1 : 0); }}", self.options.op_prefix));
        self.emit_line(&format!("static inline bool {}test(uint64_t a, uint64_t b) {{ return (a & b) != 0; }}", self.options.op_prefix));
        self.emit_line("");
        
        // Bit manipulation
        self.emit_line(&format!("static inline uint64_t {}set_bit(uint64_t x, uint64_t n) {{ return x | (1ULL << n); }}", self.options.op_prefix));
        self.emit_line(&format!("static inline uint64_t {}clear_bit(uint64_t x, uint64_t n) {{ return x & ~(1ULL << n); }}", self.options.op_prefix));
        self.emit_line(&format!("static inline uint64_t {}toggle_bit(uint64_t x, uint64_t n) {{ return x ^ (1ULL << n); }}", self.options.op_prefix));
        self.emit_line(&format!("static inline bool {}test_bit(uint64_t x, uint64_t n) {{ return (x & (1ULL << n)) != 0; }}", self.options.op_prefix));
        self.emit_line("");
        
        // Control flow
        self.emit_line(&format!("static inline void {}nop(void) {{ }}", self.options.op_prefix));
        self.emit_line("");

        self.emit_line("/* Platform-specific operation declarations */");
        self.emit_line("/* These functions should be provided by the target platform. */");
        self.emit_line(&format!("/* All platform operations use the '{}' prefix. */", self.options.op_prefix));
        self.emit_line("/* Example declarations: */");
        self.emit_line(&format!("/*   uint8_t {}gpio_read(uint64_t pin); */", self.options.op_prefix));
        self.emit_line(&format!("/*   void {}gpio_write(uint64_t pin, uint64_t value); */", self.options.op_prefix));
        self.emit_line(&format!("/*   void {}delay_ms(uint64_t ms); */", self.options.op_prefix));
        self.emit_line("");
    }

    fn emit_inline_binop(&mut self, name: &str, op: &str) {
        self.emit_line(&format!(
            "static inline uint64_t {}{}(uint64_t a, uint64_t b) {{ return a {} b; }}",
            self.options.op_prefix, name, op
        ));
    }

    /// Mangle a function name to avoid symbol collisions.
    fn mangle_name(&self, name: &str) -> String {
        format!("{}{}", self.options.mangle_prefix, name)
    }

    fn emit_const(&mut self, constant: &ConstDecl) -> Result<(), CodegenError> {
        let _c_type = self.type_to_c(&constant.ty);
        let value = self.expr_to_c(&constant.value)?;
        self.emit_line(&format!("#define {} ({})", constant.name, value));
        Ok(())
    }

    fn emit_function_decl(&mut self, function: &Function) -> Result<(), CodegenError> {
        let return_type = match &function.return_type {
            Some(ty) => self.type_to_c(ty),
            None => "void".to_string(),
        };

        let params = function
            .params
            .iter()
            .map(|p| format!("{} {}", self.type_to_c(&p.ty), p.name))
            .collect::<Vec<_>>()
            .join(", ");

        let params = if params.is_empty() {
            "void".to_string()
        } else {
            params
        };

        let mangled_name = self.mangle_name(&function.name);
        self.emit_line(&format!("{} {}({});", return_type, mangled_name, params));
        Ok(())
    }

    fn emit_function(&mut self, function: &Function) -> Result<(), CodegenError> {
        // Save the current type context and add function parameters
        let saved_ctx = self.type_ctx.clone();
        for param in &function.params {
            self.type_ctx.add_variable(param.name.clone(), param.ty.clone());
        }

        let return_type = match &function.return_type {
            Some(ty) => self.type_to_c(ty),
            None => "void".to_string(),
        };

        let params = function
            .params
            .iter()
            .map(|p| format!("{} {}", self.type_to_c(&p.ty), p.name))
            .collect::<Vec<_>>()
            .join(", ");

        let params = if params.is_empty() {
            "void".to_string()
        } else {
            params
        };

        let mangled_name = self.mangle_name(&function.name);
        self.emit_line(&format!("{} {}({}) {{", return_type, mangled_name, params));
        self.indent += 1;

        self.emit_block(&function.body, function.return_type.is_some())?;

        self.indent -= 1;
        self.emit_line("}");

        // Restore the type context
        self.type_ctx = saved_ctx;
        Ok(())
    }

    fn emit_block(&mut self, block: &Block, has_return: bool) -> Result<(), CodegenError> {
        for stmt in &block.statements {
            self.emit_statement(stmt)?;
        }

        if let Some(result) = &block.result {
            if has_return {
                let expr = self.expr_to_c(result)?;
                self.emit_line(&format!("return {};", expr));
            } else {
                let expr = self.expr_to_c(result)?;
                self.emit_line(&format!("{};", expr));
            }
        }

        Ok(())
    }

    fn emit_statement(&mut self, stmt: &Statement) -> Result<(), CodegenError> {
        match stmt {
            Statement::Let {
                name,
                mutable: _,
                ty,
                value,
            } => {
                // Use explicit type if provided, otherwise infer the type
                let inferred_ty = ty.as_ref().cloned().or_else(|| infer_expression_type(value, &self.type_ctx));
                let c_type = inferred_ty
                    .as_ref()
                    .map(|t| self.type_to_c(t))
                    .unwrap_or_else(|| "uint64_t".to_string());
                
                // Add the variable to the type context for future inference
                if let Some(var_ty) = inferred_ty {
                    self.type_ctx.add_variable(name.clone(), var_ty);
                }
                
                let expr = self.expr_to_c(value)?;
                self.emit_line(&format!("{} {} = {};", c_type, name, expr));
            }

            Statement::Assign { target, value } => {
                let expr = self.expr_to_c(value)?;
                self.emit_line(&format!("{} = {};", target, expr));
            }

            Statement::Expr(expr) => {
                let c_expr = self.expr_to_c(expr)?;
                self.emit_line(&format!("{};", c_expr));
            }

            Statement::If {
                condition,
                then_block,
                else_block,
            } => {
                let cond = self.expr_to_c(condition)?;
                self.emit_line(&format!("if ({}) {{", cond));
                self.indent += 1;
                self.emit_block(then_block, false)?;
                self.indent -= 1;

                match else_block {
                    Some(ElseBlock::Block(blk)) => {
                        self.emit_line("} else {");
                        self.indent += 1;
                        self.emit_block(blk, false)?;
                        self.indent -= 1;
                        self.emit_line("}");
                    }
                    Some(ElseBlock::ElseIf(stmt)) => {
                        self.emit("} else ");
                        self.emit_statement(stmt)?;
                    }
                    None => {
                        self.emit_line("}");
                    }
                }
            }

            Statement::For {
                variable,
                start,
                end,
                direction,
                body,
            } => {
                let start_expr = self.expr_to_c(start)?;
                let end_expr = self.expr_to_c(end)?;

                let (cond, update) = match direction {
                    RangeDirection::To => (
                        format!("{} <= {}", variable, end_expr),
                        format!("{}++", variable),
                    ),
                    RangeDirection::DownTo => (
                        format!("{} >= {}", variable, end_expr),
                        format!("{}--", variable),
                    ),
                };

                self.emit_line(&format!(
                    "for (int64_t {} = {}; {}; {}) {{",
                    variable, start_expr, cond, update
                ));
                self.indent += 1;
                self.emit_block(body, false)?;
                self.indent -= 1;
                self.emit_line("}");
            }

            Statement::Repeat { count, body } => {
                let count_expr = self.expr_to_c(count)?;
                let loop_var = self.fresh_temp();
                self.emit_line(&format!(
                    "for (uint64_t {} = 0; {} < {}; {}++) {{",
                    loop_var, loop_var, count_expr, loop_var
                ));
                self.indent += 1;
                self.emit_block(body, false)?;
                self.indent -= 1;
                self.emit_line("}");
            }

            Statement::While {
                condition,
                max_iterations,
                body,
            } => {
                let cond = self.expr_to_c(condition)?;
                let max = self.expr_to_c(max_iterations)?;
                let counter = self.fresh_temp();
                self.emit_line(&format!("uint64_t {} = 0;", counter));
                self.emit_line(&format!(
                    "while (({}) && ({} < {})) {{",
                    cond, counter, max
                ));
                self.indent += 1;
                self.emit_block(body, false)?;
                self.emit_line(&format!("{}++;", counter));
                self.indent -= 1;
                self.emit_line("}");
            }
        }

        Ok(())
    }

    fn expr_to_c(&mut self, expr: &Expression) -> Result<String, CodegenError> {
        match expr {
            Expression::Literal(lit) => match lit {
                Literal::Integer(n) => Ok(format!("{}ULL", n)),
                Literal::Float(f) => Ok(format!("{}", f)),
                Literal::Bool(b) => Ok(if *b { "1".to_string() } else { "0".to_string() }),
            },

            Expression::Identifier(name) => Ok(name.clone()),

            Expression::Binary { op, left, right } => {
                let l = self.expr_to_c(left)?;
                let r = self.expr_to_c(right)?;
                let op_str = match op {
                    BinaryOp::Add => "+",
                    BinaryOp::Sub => "-",
                    BinaryOp::Mul => "*",
                    BinaryOp::Div => "/",
                    BinaryOp::Mod => "%",
                    BinaryOp::BitAnd => "&",
                    BinaryOp::BitOr => "|",
                    BinaryOp::BitXor => "^",
                    BinaryOp::Shl => "<<",
                    BinaryOp::Shr => ">>",
                    BinaryOp::LogicalShr => ">>",
                    BinaryOp::Eq => "==",
                    BinaryOp::Ne => "!=",
                    BinaryOp::Lt => "<",
                    BinaryOp::Le => "<=",
                    BinaryOp::Gt => ">",
                    BinaryOp::Ge => ">=",
                    BinaryOp::And => "&&",
                    BinaryOp::Or => "||",
                };
                Ok(format!("({} {} {})", l, op_str, r))
            }

            Expression::Unary { op, operand } => {
                let o = self.expr_to_c(operand)?;
                let op_str = match op {
                    UnaryOp::Neg => "-",
                    UnaryOp::BitNot => "~",
                    UnaryOp::Not => "!",
                };
                Ok(format!("({}{})", op_str, o))
            }

            Expression::If {
                condition,
                then_branch,
                else_branch,
            } => {
                let cond = self.expr_to_c(condition)?;
                // For simple expressions, use ternary operator
                if then_branch.statements.is_empty() && else_branch.statements.is_empty() {
                    if let (Some(then_expr), Some(else_expr)) =
                        (&then_branch.result, &else_branch.result)
                    {
                        let t = self.expr_to_c(then_expr)?;
                        let e = self.expr_to_c(else_expr)?;
                        return Ok(format!("({} ? {} : {})", cond, t, e));
                    }
                }
                // For complex blocks, use GCC statement expressions if enabled
                if self.options.use_gcc_statement_exprs {
                    self.emit_if_expr_gcc(condition, then_branch, else_branch)
                } else {
                    Err(CodegenError::new(
                        "complex if expressions not supported in expression context (enable GCC extensions)",
                    ))
                }
            }

            Expression::Operation { kind, args } => {
                self.emit_operation(*kind, args)
            }

            Expression::Call { function, args } => {
                let arg_strs: Result<Vec<_>, _> =
                    args.iter().map(|a| self.expr_to_c(a)).collect();
                let arg_strs = arg_strs?;
                let mangled_name = self.mangle_name(function);
                Ok(format!("{}({})", mangled_name, arg_strs.join(", ")))
            }

            Expression::Block(blk) => {
                if self.options.use_gcc_statement_exprs {
                    self.emit_block_expr_gcc(blk)
                } else {
                    Err(CodegenError::new("block expressions not supported in expression context (enable GCC extensions)"))
                }
            }

            Expression::Index { array, index } => {
                let arr = self.expr_to_c(array)?;
                let idx = self.expr_to_c(index)?;
                Ok(format!("{}[{}]", arr, idx))
            }

            Expression::Array(elements) => {
                let elem_strs: Result<Vec<_>, _> =
                    elements.iter().map(|e| self.expr_to_c(e)).collect();
                let elem_strs = elem_strs?;
                Ok(format!("{{{}}}", elem_strs.join(", ")))
            }

            Expression::Cast { value, ty } => {
                let v = self.expr_to_c(value)?;
                let c_type = self.type_to_c(ty);
                Ok(format!("(({}){})", c_type, v))
            }
        }
    }

    fn emit_operation(&mut self, kind: OpKind, args: &[Expression]) -> Result<String, CodegenError> {
        let arg_strs: Result<Vec<_>, _> = args.iter().map(|a| self.expr_to_c(a)).collect();
        let arg_strs = arg_strs?;

        // Generate the operation call
        let op_name = self.op_kind_to_c_name(kind);
        
        // Some operations map directly to C operators
        match kind {
            OpKind::Add if arg_strs.len() == 2 => {
                Ok(format!("({} + {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Sub if arg_strs.len() == 2 => {
                Ok(format!("({} - {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Mul if arg_strs.len() == 2 => {
                Ok(format!("({} * {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Div if arg_strs.len() == 2 => {
                // Division by zero returns zero in Embeem
                Ok(format!("({1} != 0 ? ({0}) / ({1}) : 0)", arg_strs[0], arg_strs[1]))
            }
            OpKind::Mod if arg_strs.len() == 2 => {
                Ok(format!("({1} != 0 ? ({0}) % ({1}) : 0)", arg_strs[0], arg_strs[1]))
            }
            OpKind::Inc if arg_strs.len() == 1 => {
                Ok(format!("({} + 1)", arg_strs[0]))
            }
            OpKind::Dec if arg_strs.len() == 1 => {
                Ok(format!("({} - 1)", arg_strs[0]))
            }
            OpKind::Neg if arg_strs.len() == 1 => {
                Ok(format!("(-{})", arg_strs[0]))
            }
            OpKind::Abs if arg_strs.len() == 1 => {
                Ok(format!("(({0}) < 0 ? -({0}) : ({0}))", arg_strs[0]))
            }
            OpKind::And if arg_strs.len() == 2 => {
                Ok(format!("({} & {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Or if arg_strs.len() == 2 => {
                Ok(format!("({} | {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Xor if arg_strs.len() == 2 => {
                Ok(format!("({} ^ {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Not if arg_strs.len() == 1 => {
                Ok(format!("(~{})", arg_strs[0]))
            }
            OpKind::Shl if arg_strs.len() == 2 => {
                Ok(format!("({} << {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Shr if arg_strs.len() == 2 => {
                Ok(format!("({} >> {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Eq if arg_strs.len() == 2 => {
                Ok(format!("({} == {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Ne if arg_strs.len() == 2 => {
                Ok(format!("({} != {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Lt if arg_strs.len() == 2 => {
                Ok(format!("({} < {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Le if arg_strs.len() == 2 => {
                Ok(format!("({} <= {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Gt if arg_strs.len() == 2 => {
                Ok(format!("({} > {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Ge if arg_strs.len() == 2 => {
                Ok(format!("({} >= {})", arg_strs[0], arg_strs[1]))
            }
            OpKind::Nop => Ok("((void)0)".to_string()),
            _ => {
                // For other operations, generate a function call
                Ok(format!("{}({})", op_name, arg_strs.join(", ")))
            }
        }
    }

    fn op_kind_to_c_name(&self, kind: OpKind) -> String {
        let prefix = &self.options.op_prefix;
        match kind {
            // Operations with inline implementations (use op_prefix)
            OpKind::Add => format!("{}add", prefix),
            OpKind::Sub => format!("{}sub", prefix),
            OpKind::Mul => format!("{}mul", prefix),
            OpKind::Div => format!("{}div", prefix),
            OpKind::Mod => format!("{}mod", prefix),
            OpKind::Inc => format!("{}inc", prefix),
            OpKind::Dec => format!("{}dec", prefix),
            OpKind::Neg => format!("{}neg", prefix),
            OpKind::Abs => format!("{}abs", prefix),
            OpKind::And => format!("{}and", prefix),
            OpKind::Or => format!("{}or", prefix),
            OpKind::Xor => format!("{}xor", prefix),
            OpKind::Not => format!("{}not", prefix),
            OpKind::Shl => format!("{}shl", prefix),
            OpKind::Shr => format!("{}shr", prefix),
            OpKind::Sar => format!("{}sar", prefix),
            OpKind::Rol => format!("{}rol", prefix),
            OpKind::Ror => format!("{}ror", prefix),
            OpKind::Cmp => format!("{}cmp", prefix),
            OpKind::Test => format!("{}test", prefix),
            OpKind::Eq => format!("{}eq", prefix),
            OpKind::Ne => format!("{}ne", prefix),
            OpKind::Lt => format!("{}lt", prefix),
            OpKind::Le => format!("{}le", prefix),
            OpKind::Gt => format!("{}gt", prefix),
            OpKind::Ge => format!("{}ge", prefix),
            OpKind::Nop => format!("{}nop", prefix),
            OpKind::SetBit => format!("{}set_bit", prefix),
            OpKind::ClearBit => format!("{}clear_bit", prefix),
            OpKind::ToggleBit => format!("{}toggle_bit", prefix),
            OpKind::TestBit => format!("{}test_bit", prefix),
            OpKind::CountOnes => format!("{}count_ones", prefix),
            OpKind::CountZeros => format!("{}count_zeros", prefix),
            OpKind::FindFirstSet => format!("{}find_first_set", prefix),
            OpKind::FindFirstZero => format!("{}find_first_zero", prefix),
            OpKind::FAdd => format!("{}fadd", prefix),
            OpKind::FSub => format!("{}fsub", prefix),
            OpKind::FMul => format!("{}fmul", prefix),
            OpKind::FDiv => format!("{}fdiv", prefix),
            OpKind::FSqrt => format!("{}fsqrt", prefix),
            OpKind::FAbs => format!("{}fabs", prefix),
            OpKind::FCmp => format!("{}fcmp", prefix),
            OpKind::Halt => format!("{}halt", prefix),
            OpKind::Sleep => format!("{}sleep", prefix),
            // Platform-specific operations (use op_prefix but not defined inline)
            OpKind::GpioRead => format!("{}gpio_read", prefix),
            OpKind::GpioWrite => format!("{}gpio_write", prefix),
            OpKind::GpioToggle => format!("{}gpio_toggle", prefix),
            OpKind::GpioSetMode => format!("{}gpio_set_mode", prefix),
            OpKind::GpioReadPort => format!("{}gpio_read_port", prefix),
            OpKind::GpioWritePort => format!("{}gpio_write_port", prefix),
            OpKind::AdcRead => format!("{}adc_read", prefix),
            OpKind::AdcStartConversion => format!("{}adc_start_conversion", prefix),
            OpKind::AdcReadMulti => format!("{}adc_read_multi", prefix),
            OpKind::DacWrite => format!("{}dac_write", prefix),
            OpKind::AdcSetResolution => format!("{}adc_set_resolution", prefix),
            OpKind::AdcSetReference => format!("{}adc_set_reference", prefix),
            OpKind::PwmStart => format!("{}pwm_start", prefix),
            OpKind::PwmStop => format!("{}pwm_stop", prefix),
            OpKind::PwmSetDutyCycle => format!("{}pwm_set_duty_cycle", prefix),
            OpKind::PwmSetFrequency => format!("{}pwm_set_frequency", prefix),
            OpKind::PwmSetPulseWidth => format!("{}pwm_set_pulse_width", prefix),
            OpKind::TimerStart => format!("{}timer_start", prefix),
            OpKind::TimerStop => format!("{}timer_stop", prefix),
            OpKind::TimerReset => format!("{}timer_reset", prefix),
            OpKind::TimerRead => format!("{}timer_read", prefix),
            OpKind::TimerSetPeriod => format!("{}timer_set_period", prefix),
            OpKind::TimerSetCompare => format!("{}timer_set_compare", prefix),
            OpKind::GetMillis => format!("{}get_millis", prefix),
            OpKind::GetMicros => format!("{}get_micros", prefix),
            OpKind::DelayMs => format!("{}delay_ms", prefix),
            OpKind::DelayUs => format!("{}delay_us", prefix),
            OpKind::UartInit => format!("{}uart_init", prefix),
            OpKind::UartWriteByte => format!("{}uart_write_byte", prefix),
            OpKind::UartWriteBuffer => format!("{}uart_write_buffer", prefix),
            OpKind::UartReadByte => format!("{}uart_read_byte", prefix),
            OpKind::UartReadBuffer => format!("{}uart_read_buffer", prefix),
            OpKind::UartAvailable => format!("{}uart_available", prefix),
            OpKind::UartFlush => format!("{}uart_flush", prefix),
            OpKind::UartSetBaudRate => format!("{}uart_set_baud_rate", prefix),
            OpKind::SpiInit => format!("{}spi_init", prefix),
            OpKind::SpiTransfer => format!("{}spi_transfer", prefix),
            OpKind::SpiTransferBuffer => format!("{}spi_transfer_buffer", prefix),
            OpKind::SpiSetMode => format!("{}spi_set_mode", prefix),
            OpKind::SpiSetClock => format!("{}spi_set_clock", prefix),
            OpKind::SpiSetBitOrder => format!("{}spi_set_bit_order", prefix),
            OpKind::SpiBeginTransaction => format!("{}spi_begin_transaction", prefix),
            OpKind::SpiEndTransaction => format!("{}spi_end_transaction", prefix),
            OpKind::I2cInit => format!("{}i2c_init", prefix),
            OpKind::I2cStart => format!("{}i2c_start", prefix),
            OpKind::I2cStop => format!("{}i2c_stop", prefix),
            OpKind::I2cWrite => format!("{}i2c_write", prefix),
            OpKind::I2cRead => format!("{}i2c_read", prefix),
            OpKind::I2cWriteTo => format!("{}i2c_write_to", prefix),
            OpKind::I2cReadFrom => format!("{}i2c_read_from", prefix),
            OpKind::I2cSetClock => format!("{}i2c_set_clock", prefix),
            OpKind::I2cScan => format!("{}i2c_scan", prefix),
            OpKind::CanInit => format!("{}can_init", prefix),
            OpKind::CanSend => format!("{}can_send", prefix),
            OpKind::CanReceive => format!("{}can_receive", prefix),
            OpKind::CanSetFilter => format!("{}can_set_filter", prefix),
            OpKind::CanSetBitrate => format!("{}can_set_bitrate", prefix),
            OpKind::UsbInit => format!("{}usb_init", prefix),
            OpKind::UsbConnect => format!("{}usb_connect", prefix),
            OpKind::UsbDisconnect => format!("{}usb_disconnect", prefix),
            OpKind::UsbWrite => format!("{}usb_write", prefix),
            OpKind::UsbRead => format!("{}usb_read", prefix),
            OpKind::UsbAvailable => format!("{}usb_available", prefix),
            OpKind::WdtEnable => format!("{}wdt_enable", prefix),
            OpKind::WdtDisable => format!("{}wdt_disable", prefix),
            OpKind::WdtReset => format!("{}wdt_reset", prefix),
            OpKind::WdtSetTimeout => format!("{}wdt_set_timeout", prefix),
            OpKind::DmaInit => format!("{}dma_init", prefix),
            OpKind::DmaStart => format!("{}dma_start", prefix),
            OpKind::DmaStop => format!("{}dma_stop", prefix),
            OpKind::DmaConfig => format!("{}dma_config", prefix),
            OpKind::DmaSetSource => format!("{}dma_set_source", prefix),
            OpKind::DmaSetDestination => format!("{}dma_set_destination", prefix),
            OpKind::EepromRead => format!("{}eeprom_read", prefix),
            OpKind::EepromWrite => format!("{}eeprom_write", prefix),
            OpKind::EepromUpdate => format!("{}eeprom_update", prefix),
            OpKind::FlashRead => format!("{}flash_read", prefix),
            OpKind::FlashWrite => format!("{}flash_write", prefix),
            OpKind::FlashErase => format!("{}flash_erase", prefix),
            OpKind::SetPowerMode => format!("{}set_power_mode", prefix),
            OpKind::DisablePeripheral => format!("{}disable_peripheral", prefix),
            OpKind::EnablePeripheral => format!("{}enable_peripheral", prefix),
            OpKind::SetClockSpeed => format!("{}set_clock_speed", prefix),
            OpKind::EnterStandby => format!("{}enter_standby", prefix),
            OpKind::EnterDeepSleep => format!("{}enter_deep_sleep", prefix),
            OpKind::RtcInit => format!("{}rtc_init", prefix),
            OpKind::RtcSetTime => format!("{}rtc_set_time", prefix),
            OpKind::RtcGetTime => format!("{}rtc_get_time", prefix),
            OpKind::RtcSetAlarm => format!("{}rtc_set_alarm", prefix),
            OpKind::RtcSetCalendar => format!("{}rtc_set_calendar", prefix),
        }
    }

    /// Emit a block expression using GCC statement expression syntax: `({ ... })`
    fn emit_block_expr_gcc(&mut self, block: &Block) -> Result<String, CodegenError> {
        let mut result = String::from("({ ");
        
        // Emit statements inline
        for stmt in &block.statements {
            let stmt_str = self.emit_statement_to_string(stmt)?;
            result.push_str(&stmt_str);
            result.push(' ');
        }
        
        // Emit result expression if present
        if let Some(ref expr) = block.result {
            let expr_str = self.expr_to_c(expr)?;
            result.push_str(&expr_str);
            result.push_str("; ");
        }
        
        result.push_str("})");
        Ok(result)
    }

    /// Emit an if expression using GCC statement expression syntax.
    fn emit_if_expr_gcc(
        &mut self,
        condition: &Expression,
        then_branch: &Block,
        else_branch: &Block,
    ) -> Result<String, CodegenError> {
        let cond = self.expr_to_c(condition)?;
        let result_var = self.fresh_temp();
        
        let mut result = format!("({{ uint64_t {}; if ({}) {{ ", result_var, cond);
        
        // Then branch
        for stmt in &then_branch.statements {
            let stmt_str = self.emit_statement_to_string(stmt)?;
            result.push_str(&stmt_str);
            result.push(' ');
        }
        if let Some(ref expr) = then_branch.result {
            let expr_str = self.expr_to_c(expr)?;
            result.push_str(&format!("{} = {}; ", result_var, expr_str));
        }
        
        result.push_str("} else { ");
        
        // Else branch
        for stmt in &else_branch.statements {
            let stmt_str = self.emit_statement_to_string(stmt)?;
            result.push_str(&stmt_str);
            result.push(' ');
        }
        if let Some(ref expr) = else_branch.result {
            let expr_str = self.expr_to_c(expr)?;
            result.push_str(&format!("{} = {}; ", result_var, expr_str));
        }
        
        result.push_str(&format!("}} {}; }})", result_var));
        Ok(result)
    }

    /// Emit a statement to a string (for use in GCC statement expressions).
    fn emit_statement_to_string(&mut self, stmt: &Statement) -> Result<String, CodegenError> {
        match stmt {
            Statement::Let {
                name,
                mutable: _,
                ty,
                value,
            } => {
                let c_type = ty
                    .as_ref()
                    .map(|t| self.type_to_c(t))
                    .unwrap_or_else(|| "uint64_t".to_string());
                let expr = self.expr_to_c(value)?;
                Ok(format!("{} {} = {};", c_type, name, expr))
            }

            Statement::Assign { target, value } => {
                let expr = self.expr_to_c(value)?;
                Ok(format!("{} = {};", target, expr))
            }

            Statement::Expr(expr) => {
                let c_expr = self.expr_to_c(expr)?;
                Ok(format!("{};", c_expr))
            }

            Statement::If {
                condition,
                then_block,
                else_block,
            } => {
                let cond = self.expr_to_c(condition)?;
                let mut result = format!("if ({}) {{ ", cond);
                
                for s in &then_block.statements {
                    let s_str = self.emit_statement_to_string(s)?;
                    result.push_str(&s_str);
                    result.push(' ');
                }
                if let Some(ref expr) = then_block.result {
                    let expr_str = self.expr_to_c(expr)?;
                    result.push_str(&expr_str);
                    result.push_str("; ");
                }
                
                match else_block {
                    Some(ElseBlock::Block(blk)) => {
                        result.push_str("} else { ");
                        for s in &blk.statements {
                            let s_str = self.emit_statement_to_string(s)?;
                            result.push_str(&s_str);
                            result.push(' ');
                        }
                        if let Some(ref expr) = blk.result {
                            let expr_str = self.expr_to_c(expr)?;
                            result.push_str(&expr_str);
                            result.push_str("; ");
                        }
                        result.push('}');
                    }
                    Some(ElseBlock::ElseIf(stmt)) => {
                        result.push_str("} else ");
                        let stmt_str = self.emit_statement_to_string(stmt)?;
                        result.push_str(&stmt_str);
                    }
                    None => {
                        result.push('}');
                    }
                }
                
                Ok(result)
            }

            Statement::For {
                variable,
                start,
                end,
                direction,
                body,
            } => {
                let start_expr = self.expr_to_c(start)?;
                let end_expr = self.expr_to_c(end)?;

                let (cond, update) = match direction {
                    RangeDirection::To => (
                        format!("{} <= {}", variable, end_expr),
                        format!("{}++", variable),
                    ),
                    RangeDirection::DownTo => (
                        format!("{} >= {}", variable, end_expr),
                        format!("{}--", variable),
                    ),
                };

                let mut result = format!(
                    "for (int64_t {} = {}; {}; {}) {{ ",
                    variable, start_expr, cond, update
                );
                
                for s in &body.statements {
                    let s_str = self.emit_statement_to_string(s)?;
                    result.push_str(&s_str);
                    result.push(' ');
                }
                if let Some(ref expr) = body.result {
                    let expr_str = self.expr_to_c(expr)?;
                    result.push_str(&expr_str);
                    result.push_str("; ");
                }
                
                result.push('}');
                Ok(result)
            }

            Statement::Repeat { count, body } => {
                let count_expr = self.expr_to_c(count)?;
                let loop_var = self.fresh_temp();
                
                let mut result = format!(
                    "for (uint64_t {} = 0; {} < {}; {}++) {{ ",
                    loop_var, loop_var, count_expr, loop_var
                );
                
                for s in &body.statements {
                    let s_str = self.emit_statement_to_string(s)?;
                    result.push_str(&s_str);
                    result.push(' ');
                }
                if let Some(ref expr) = body.result {
                    let expr_str = self.expr_to_c(expr)?;
                    result.push_str(&expr_str);
                    result.push_str("; ");
                }
                
                result.push('}');
                Ok(result)
            }

            Statement::While {
                condition,
                max_iterations,
                body,
            } => {
                let cond = self.expr_to_c(condition)?;
                let max = self.expr_to_c(max_iterations)?;
                let counter = self.fresh_temp();
                
                let mut result = format!("uint64_t {} = 0; ", counter);
                result.push_str(&format!(
                    "while (({}) && ({} < {})) {{ ",
                    cond, counter, max
                ));
                
                for s in &body.statements {
                    let s_str = self.emit_statement_to_string(s)?;
                    result.push_str(&s_str);
                    result.push(' ');
                }
                if let Some(ref expr) = body.result {
                    let expr_str = self.expr_to_c(expr)?;
                    result.push_str(&expr_str);
                    result.push_str("; ");
                }
                
                result.push_str(&format!("{}++; }}", counter));
                Ok(result)
            }
        }
    }

    fn type_to_c(&self, ty: &Type) -> String {
        match ty {
            Type::Primitive(prim) => match prim {
                PrimitiveType::U8 => "uint8_t".to_string(),
                PrimitiveType::U16 => "uint16_t".to_string(),
                PrimitiveType::U32 => "uint32_t".to_string(),
                PrimitiveType::U64 => "uint64_t".to_string(),
                PrimitiveType::I8 => "int8_t".to_string(),
                PrimitiveType::I16 => "int16_t".to_string(),
                PrimitiveType::I32 => "int32_t".to_string(),
                PrimitiveType::I64 => "int64_t".to_string(),
                PrimitiveType::F32 => "float".to_string(),
                PrimitiveType::F64 => "double".to_string(),
                PrimitiveType::Bool => "bool".to_string(),
            },
            Type::Array(elem, size) => {
                format!("{}[{}]", self.type_to_c(elem), size)
            }
            Type::Tuple(types) => {
                // C doesn't have tuples, use a struct
                format!("struct {{ {} }}", 
                    types.iter().enumerate()
                        .map(|(i, t)| format!("{} _{}", self.type_to_c(t), i))
                        .collect::<Vec<_>>()
                        .join("; "))
            }
        }
    }

    fn fresh_temp(&mut self) -> String {
        let name = format!("_tmp{}", self.temp_counter);
        self.temp_counter += 1;
        name
    }

    fn emit(&mut self, s: &str) {
        self.output.push_str(s);
    }

    fn emit_line(&mut self, s: &str) {
        for _ in 0..self.indent {
            self.output.push_str("    ");
        }
        self.output.push_str(s);
        self.output.push('\n');
    }
}

impl Default for CCodegen {
    fn default() -> Self {
        Self::new()
    }
}

/// Convenience function to compile an Embeem program to C (standard C, no extensions).
pub fn compile_to_c(program: &Program) -> Result<String, CodegenError> {
    let mut codegen = CCodegen::new();
    codegen.generate(program)
}

/// Convenience function to compile an Embeem program to C with specified options.
pub fn compile_to_c_with_options(program: &Program, options: CodegenOptions) -> Result<String, CodegenError> {
    let mut codegen = CCodegen::with_options(options);
    codegen.generate(program)
}

/// Convenience function to compile an Embeem program to C using GCC extensions.
/// This enables GCC statement expressions `({ ... })` for block and complex if expressions.
pub fn compile_to_c_gcc(program: &Program) -> Result<String, CodegenError> {
    let options = CodegenOptions::new().with_gcc_extensions();
    let mut codegen = CCodegen::with_options(options);
    codegen.generate(program)
}

#[cfg(test)]
mod tests {
    extern crate std;
    use super::*;
    use embeem_parser::parse_program;

    #[test]
    fn test_simple_program() {
        let src = r#"
            fn main() {
                GPIO_SET_MODE(13, 1);
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        // Function names are mangled with prefix
        assert!(c_code.contains("void embeem_main(void)"));
        // GPIO operations use the op_prefix
        assert!(c_code.contains("embeem_op_gpio_set_mode"));
    }

    #[test]
    fn test_constants() {
        let src = r#"
            const LED_PIN: u8 = 13;
            fn main() {}
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        assert!(c_code.contains("#define LED_PIN"));
    }

    #[test]
    fn test_repeat_loop() {
        let src = r#"
            fn main() {
                repeat 10 {
                    DELAY_MS(100);
                }
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        assert!(c_code.contains("for"));
        assert!(c_code.contains("< 10"));
    }

    #[test]
    fn test_for_loop() {
        let src = r#"
            fn main() {
                for i in 0 to 9 {
                    GPIO_TOGGLE(i);
                }
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        assert!(c_code.contains("for"));
        assert!(c_code.contains("i++"));
    }

    #[test]
    fn test_if_statement() {
        let src = r#"
            fn main() {
                let x: u32 = 42;
                if x > 0 {
                    GPIO_WRITE(13, 1);
                } else {
                    GPIO_WRITE(13, 0);
                }
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        assert!(c_code.contains("if"));
        assert!(c_code.contains("else"));
    }

    #[test]
    fn test_gcc_statement_expressions_header() {
        let src = r#"
            fn main() {}
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c_gcc(&program).unwrap();
        assert!(c_code.contains("Using GCC statement expressions"));
    }

    #[test]
    fn test_gcc_block_expression() {
        let src = r#"
            fn get_value() -> u32 {
                let result = {
                    let x: u32 = 10;
                    x + 5
                };
                result
            }
        "#;
        let program = parse_program(src).unwrap();
        // Should fail without GCC extensions
        let result = compile_to_c(&program);
        assert!(result.is_err());
        
        // Should succeed with GCC extensions
        let c_code = compile_to_c_gcc(&program).unwrap();
        assert!(c_code.contains("({"));
        assert!(c_code.contains("})"));
    }

    #[test]
    fn test_gcc_complex_if_expression() {
        let src = r#"
            fn get_max(a: u32, b: u32) -> u32 {
                let result = if a > b {
                    let temp: u32 = a;
                    temp
                } else {
                    let temp: u32 = b;
                    temp
                };
                result
            }
        "#;
        let program = parse_program(src).unwrap();
        // Should fail without GCC extensions
        let result = compile_to_c(&program);
        assert!(result.is_err());
        
        // Should succeed with GCC extensions
        let c_code = compile_to_c_gcc(&program).unwrap();
        assert!(c_code.contains("({"));
    }

    #[test]
    fn test_simple_ternary_still_works() {
        // Simple if expressions should use ternary even without GCC extensions
        let src = r#"
            fn max_val(a: u32, b: u32) -> u32 {
                if a > b { a } else { b }
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        assert!(c_code.contains("?"), "Expected ternary operator '?', got:\n{}", c_code);
        assert!(c_code.contains(":"));
    }

    #[test]
    fn test_type_inference_for_let() {
        // Test that type inference works for let statements without explicit types
        let src = r#"
            fn main() {
                let x = 42;
                let y = true;
                let z = 3.14;
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        // x should be inferred as uint64_t (integer literal)
        assert!(c_code.contains("uint64_t x = "), "Expected uint64_t for integer literal, got:\n{}", c_code);
        // y should be inferred as bool
        assert!(c_code.contains("bool y = "), "Expected bool for boolean literal, got:\n{}", c_code);
        // z should be inferred as double (float literal)
        assert!(c_code.contains("double z = "), "Expected double for float literal, got:\n{}", c_code);
    }

    #[test]
    fn test_type_inference_comparison() {
        // Test that comparison results are inferred as bool
        let src = r#"
            fn test() {
                let x: u32 = 10;
                let y: u32 = 5;
                let is_greater = x > y;
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        // is_greater should be inferred as bool
        assert!(c_code.contains("bool is_greater = "), "Expected bool for comparison result, got:\n{}", c_code);
    }

    #[test]
    fn test_type_inference_from_variable() {
        // Test that a variable's type is inferred from another variable
        let src = r#"
            fn test() {
                let x: u16 = 100;
                let y = x;
            }
        "#;
        let program = parse_program(src).unwrap();
        let c_code = compile_to_c(&program).unwrap();
        // y should be inferred as uint16_t from x
        assert!(c_code.contains("uint16_t y = "), "Expected uint16_t for variable reference, got:\n{}", c_code);
    }
}
