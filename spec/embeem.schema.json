{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://github.com/portal-co/emback/embeem/schema/v1",
  "title": "Embeem Language Schema",
  "description": "Machine-readable specification for the Embeem total programming language",
  "version": "0.1.0",
  
  "definitions": {
    "identifier": {
      "type": "string",
      "pattern": "^[a-zA-Z_][a-zA-Z0-9_]*$",
      "description": "A valid Embeem identifier (includes both user and operation identifiers)"
    },
    
    "userIdentifier": {
      "type": "string",
      "pattern": "^(?![A-Z][A-Z0-9_]*$)[a-zA-Z_][a-zA-Z0-9_]*$",
      "description": "A valid user-defined identifier. UPPER_SNAKE_CASE is reserved for operations and cannot be used for variables, functions, constants, or parameters."
    },
    
    "operationIdentifier": {
      "type": "string",
      "pattern": "^[A-Z][A-Z0-9_]*$",
      "description": "An UPPER_SNAKE_CASE identifier reserved exclusively for operations"
    },
    
    "integerLiteral": {
      "oneOf": [
        { "type": "integer" },
        { "type": "string", "pattern": "^0x[0-9a-fA-F]+$" },
        { "type": "string", "pattern": "^0b[01]+$" }
      ]
    },
    
    "floatLiteral": {
      "type": "number"
    },
    
    "booleanLiteral": {
      "type": "boolean"
    },
    
    "primitiveType": {
      "enum": ["u8", "u16", "u32", "u64", "i8", "i16", "i32", "i64", "f32", "f64", "bool"]
    },
    
    "type": {
      "oneOf": [
        { "$ref": "#/definitions/primitiveType" },
        { "$ref": "#/definitions/arrayType" },
        { "$ref": "#/definitions/tupleType" }
      ]
    },
    
    "arrayType": {
      "type": "object",
      "properties": {
        "kind": { "const": "array" },
        "elementType": { "$ref": "#/definitions/type" },
        "size": { "type": "integer", "minimum": 0 }
      },
      "required": ["kind", "elementType", "size"]
    },
    
    "tupleType": {
      "type": "object",
      "properties": {
        "kind": { "const": "tuple" },
        "elements": {
          "type": "array",
          "items": { "$ref": "#/definitions/type" }
        }
      },
      "required": ["kind", "elements"]
    },
    
    "expression": {
      "oneOf": [
        { "$ref": "#/definitions/literalExpr" },
        { "$ref": "#/definitions/identifierExpr" },
        { "$ref": "#/definitions/binaryExpr" },
        { "$ref": "#/definitions/unaryExpr" },
        { "$ref": "#/definitions/ifExpr" },
        { "$ref": "#/definitions/operationExpr" },
        { "$ref": "#/definitions/blockExpr" },
        { "$ref": "#/definitions/callExpr" },
        { "$ref": "#/definitions/indexExpr" }
      ]
    },
    
    "literalExpr": {
      "type": "object",
      "properties": {
        "kind": { "const": "literal" },
        "value": {
          "oneOf": [
            { "$ref": "#/definitions/integerLiteral" },
            { "$ref": "#/definitions/floatLiteral" },
            { "$ref": "#/definitions/booleanLiteral" }
          ]
        },
        "type": { "$ref": "#/definitions/primitiveType" }
      },
      "required": ["kind", "value"]
    },
    
    "identifierExpr": {
      "type": "object",
      "properties": {
        "kind": { "const": "identifier" },
        "name": { "$ref": "#/definitions/identifier" }
      },
      "required": ["kind", "name"]
    },
    
    "binaryExpr": {
      "type": "object",
      "properties": {
        "kind": { "const": "binary" },
        "operator": {
          "enum": [
            "+", "-", "*", "/", "%",
            "&", "|", "^", "<<", ">>", ">>>",
            "==", "!=", "<", "<=", ">", ">=",
            "and", "or"
          ]
        },
        "left": { "$ref": "#/definitions/expression" },
        "right": { "$ref": "#/definitions/expression" }
      },
      "required": ["kind", "operator", "left", "right"]
    },
    
    "unaryExpr": {
      "type": "object",
      "properties": {
        "kind": { "const": "unary" },
        "operator": { "enum": ["-", "~", "not"] },
        "operand": { "$ref": "#/definitions/expression" }
      },
      "required": ["kind", "operator", "operand"]
    },
    
    "ifExpr": {
      "type": "object",
      "properties": {
        "kind": { "const": "if" },
        "condition": { "$ref": "#/definitions/expression" },
        "thenBranch": { "$ref": "#/definitions/expression" },
        "elseBranch": { "$ref": "#/definitions/expression" }
      },
      "required": ["kind", "condition", "thenBranch", "elseBranch"]
    },
    
    "operationExpr": {
      "type": "object",
      "description": "An operation call with a path of UPPER_SNAKE_CASE segments. The path is built by collecting nested operation identifiers.",
      "properties": {
        "kind": { "const": "operation" },
        "path": {
          "type": "array",
          "items": { "$ref": "#/definitions/operationIdentifier" },
          "minItems": 1,
          "description": "Path segments collected from nested UPPER_SNAKE_CASE calls. E.g., WRITE(GPIO(13), 1) becomes ['WRITE', 'GPIO']"
        },
        "arguments": {
          "type": "array",
          "items": { "$ref": "#/definitions/expression" },
          "description": "All non-path arguments collected from the innermost call outward"
        }
      },
      "required": ["kind", "path", "arguments"],
      "examples": [
        {
          "kind": "operation",
          "path": ["FSUB"],
          "arguments": [
            { "kind": "identifier", "name": "a" },
            { "kind": "identifier", "name": "b" }
          ],
          "_comment": "FSUB(a, b)"
        },
        {
          "kind": "operation",
          "path": ["WRITE", "GPIO"],
          "arguments": [
            { "kind": "literal", "value": 13 },
            { "kind": "literal", "value": 1 }
          ],
          "_comment": "WRITE(GPIO(13), 1)"
        },
        {
          "kind": "operation",
          "path": ["SET_FREQUENCY", "PWM"],
          "arguments": [
            { "kind": "literal", "value": 0 },
            { "kind": "literal", "value": 1000 }
          ],
          "_comment": "SET_FREQUENCY(PWM(0), 1000)"
        }
      ],
      "manglingScheme": {
        "description": "Operation paths are mangled to C function names by: 1) joining segments with underscores, 2) converting to lowercase, 3) prepending the operation prefix (embeem_op_ by default)",
        "examples": [
          { "path": ["FSUB"], "mangledName": "embeem_op_fsub" },
          { "path": ["GPIO_READ"], "mangledName": "embeem_op_gpio_read" },
          { "path": ["READ", "GPIO"], "mangledName": "embeem_op_read_gpio" },
          { "path": ["WRITE", "GPIO"], "mangledName": "embeem_op_write_gpio" },
          { "path": ["SET_FREQUENCY", "PWM"], "mangledName": "embeem_op_set_frequency_pwm" }
        ],
        "note": "Single-segment paths for built-in C operators (ADD, SUB, MUL, etc.) may be inlined directly as C operators rather than function calls"
      }
    },
    
    "blockExpr": {
      "type": "object",
      "properties": {
        "kind": { "const": "block" },
        "statements": {
          "type": "array",
          "items": { "$ref": "#/definitions/statement" }
        },
        "result": { "$ref": "#/definitions/expression" }
      },
      "required": ["kind", "statements"]
    },
    
    "callExpr": {
      "type": "object",
      "properties": {
        "kind": { "const": "call" },
        "function": { "$ref": "#/definitions/userIdentifier" },
        "arguments": {
          "type": "array",
          "items": { "$ref": "#/definitions/expression" }
        }
      },
      "required": ["kind", "function", "arguments"]
    },
    
    "indexExpr": {
      "type": "object",
      "properties": {
        "kind": { "const": "index" },
        "array": { "$ref": "#/definitions/expression" },
        "index": { "$ref": "#/definitions/expression" }
      },
      "required": ["kind", "array", "index"]
    },
    
    "statement": {
      "oneOf": [
        { "$ref": "#/definitions/letStatement" },
        { "$ref": "#/definitions/assignStatement" },
        { "$ref": "#/definitions/exprStatement" },
        { "$ref": "#/definitions/ifStatement" },
        { "$ref": "#/definitions/forStatement" },
        { "$ref": "#/definitions/repeatStatement" },
        { "$ref": "#/definitions/whileStatement" }
      ]
    },
    
    "letStatement": {
      "type": "object",
      "properties": {
        "kind": { "const": "let" },
        "name": { "$ref": "#/definitions/userIdentifier" },
        "mutable": { "type": "boolean", "default": false },
        "type": { "$ref": "#/definitions/type" },
        "value": { "$ref": "#/definitions/expression" }
      },
      "required": ["kind", "name", "value"],
      "description": "Variable names must not use UPPER_SNAKE_CASE (reserved for operations)"
    },
    
    "assignStatement": {
      "type": "object",
      "properties": {
        "kind": { "const": "assign" },
        "target": { "$ref": "#/definitions/userIdentifier" },
        "value": { "$ref": "#/definitions/expression" }
      },
      "required": ["kind", "target", "value"]
    },
    
    "exprStatement": {
      "type": "object",
      "properties": {
        "kind": { "const": "expr" },
        "expression": { "$ref": "#/definitions/expression" }
      },
      "required": ["kind", "expression"]
    },
    
    "ifStatement": {
      "type": "object",
      "properties": {
        "kind": { "const": "if_stmt" },
        "condition": { "$ref": "#/definitions/expression" },
        "thenBlock": { "$ref": "#/definitions/block" },
        "elseBlock": {
          "oneOf": [
            { "$ref": "#/definitions/block" },
            { "$ref": "#/definitions/ifStatement" },
            { "type": "null" }
          ]
        }
      },
      "required": ["kind", "condition", "thenBlock"]
    },
    
    "forStatement": {
      "type": "object",
      "properties": {
        "kind": { "const": "for" },
        "variable": { "$ref": "#/definitions/userIdentifier" },
        "start": { "$ref": "#/definitions/expression" },
        "end": { "$ref": "#/definitions/expression" },
        "direction": { "enum": ["to", "downto"] },
        "body": { "$ref": "#/definitions/block" }
      },
      "required": ["kind", "variable", "start", "end", "direction", "body"],
      "description": "Loop bounds must be compile-time constants for totality. Loop variable must not use UPPER_SNAKE_CASE."
    },
    
    "repeatStatement": {
      "type": "object",
      "properties": {
        "kind": { "const": "repeat" },
        "count": { "$ref": "#/definitions/expression" },
        "body": { "$ref": "#/definitions/block" }
      },
      "required": ["kind", "count", "body"],
      "description": "Count must be a compile-time constant for totality"
    },
    
    "whileStatement": {
      "type": "object",
      "properties": {
        "kind": { "const": "bounded_while" },
        "condition": { "$ref": "#/definitions/expression" },
        "maxIterations": { "$ref": "#/definitions/expression" },
        "body": { "$ref": "#/definitions/block" }
      },
      "required": ["kind", "condition", "maxIterations", "body"],
      "description": "maxIterations must be a compile-time constant for totality"
    },
    
    "block": {
      "type": "object",
      "properties": {
        "statements": {
          "type": "array",
          "items": { "$ref": "#/definitions/statement" }
        },
        "result": { "$ref": "#/definitions/expression" }
      },
      "required": ["statements"]
    },
    
    "function": {
      "type": "object",
      "properties": {
        "name": { "$ref": "#/definitions/userIdentifier" },
        "parameters": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "$ref": "#/definitions/userIdentifier" },
              "type": { "$ref": "#/definitions/type" }
            },
            "required": ["name", "type"]
          }
        },
        "returnType": { "$ref": "#/definitions/type" },
        "body": { "$ref": "#/definitions/block" }
      },
      "required": ["name", "parameters", "body"],
      "description": "Function and parameter names must not use UPPER_SNAKE_CASE (reserved for operations)"
    },
    
    "constDecl": {
      "type": "object",
      "properties": {
        "kind": { "const": "const" },
        "name": { "$ref": "#/definitions/userIdentifier" },
        "type": { "$ref": "#/definitions/type" },
        "value": { "$ref": "#/definitions/expression" }
      },
      "required": ["kind", "name", "type", "value"],
      "description": "Constant names must not use UPPER_SNAKE_CASE (reserved for operations)"
    },
    
    "operationArity": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "ADD": { "const": 2 },
        "SUB": { "const": 2 },
        "MUL": { "const": 2 },
        "DIV": { "const": 2 },
        "MOD": { "const": 2 },
        "INC": { "const": 1 },
        "DEC": { "const": 1 },
        "NEG": { "const": 1 },
        "ABS": { "const": 1 },
        "AND": { "const": 2 },
        "OR": { "const": 2 },
        "XOR": { "const": 2 },
        "NOT": { "const": 1 },
        "SHL": { "const": 2 },
        "SHR": { "const": 2 },
        "SAR": { "const": 2 },
        "ROL": { "const": 2 },
        "ROR": { "const": 2 },
        "CMP": { "const": 2 },
        "TEST": { "const": 2 },
        "EQ": { "const": 2 },
        "NE": { "const": 2 },
        "LT": { "const": 2 },
        "LE": { "const": 2 },
        "GT": { "const": 2 },
        "GE": { "const": 2 },
        "NOP": { "const": 0 },
        "HALT": { "const": 0 },
        "SLEEP": { "const": 0 },
        "GPIO_READ": { "const": 1 },
        "GPIO_WRITE": { "const": 2 },
        "GPIO_TOGGLE": { "const": 1 },
        "GPIO_SET_MODE": { "const": 2 },
        "GPIO_READ_PORT": { "const": 1 },
        "GPIO_WRITE_PORT": { "const": 2 },
        "ADC_READ": { "const": 1 },
        "DAC_WRITE": { "const": 2 },
        "ADC_SET_RESOLUTION": { "const": 1 },
        "PWM_START": { "const": 1 },
        "PWM_STOP": { "const": 1 },
        "PWM_SET_DUTY_CYCLE": { "const": 2 },
        "PWM_SET_FREQUENCY": { "const": 2 },
        "TIMER_START": { "const": 1 },
        "TIMER_STOP": { "const": 1 },
        "TIMER_RESET": { "const": 1 },
        "TIMER_READ": { "const": 1 },
        "TIMER_SET_PERIOD": { "const": 2 },
        "GET_MILLIS": { "const": 0 },
        "GET_MICROS": { "const": 0 },
        "DELAY_MS": { "const": 1 },
        "DELAY_US": { "const": 1 },
        "UART_INIT": { "const": 1 },
        "UART_WRITE_BYTE": { "const": 2 },
        "UART_READ_BYTE": { "const": 1 },
        "UART_AVAILABLE": { "const": 1 },
        "UART_FLUSH": { "const": 1 },
        "UART_SET_BAUD_RATE": { "const": 2 },
        "I2C_INIT": { "const": 1 },
        "I2C_START": { "const": 1 },
        "I2C_STOP": { "const": 1 },
        "I2C_WRITE_TO": { "const": 3 },
        "I2C_READ_FROM": { "const": 2 },
        "I2C_SET_CLOCK": { "const": 2 },
        "WDT_ENABLE": { "const": 0 },
        "WDT_DISABLE": { "const": 0 },
        "WDT_RESET": { "const": 0 },
        "WDT_SET_TIMEOUT": { "const": 1 }
      }
    }
  },
  
  "type": "object",
  "properties": {
    "program": {
      "type": "object",
      "properties": {
        "constants": {
          "type": "array",
          "items": { "$ref": "#/definitions/constDecl" }
        },
        "functions": {
          "type": "array",
          "items": { "$ref": "#/definitions/function" }
        },
        "main": { "$ref": "#/definitions/function" }
      },
      "required": ["functions", "main"]
    }
  },
  
  "totalityConstraints": {
    "description": "Constraints that ensure program termination",
    "rules": [
      {
        "id": "bounded-for",
        "description": "for loop bounds must be compile-time constants",
        "applies_to": "forStatement",
        "constraint": "start and end must be const_expr"
      },
      {
        "id": "bounded-repeat",
        "description": "repeat count must be a compile-time constant",
        "applies_to": "repeatStatement",
        "constraint": "count must be const_expr"
      },
      {
        "id": "bounded-while",
        "description": "while loops must have maximum iteration bound",
        "applies_to": "whileStatement",
        "constraint": "maxIterations must be const_expr"
      },
      {
        "id": "no-recursion",
        "description": "functions cannot call themselves directly or indirectly",
        "applies_to": "function",
        "constraint": "call graph must be acyclic (DAG)"
      },
      {
        "id": "total-primitives",
        "description": "all primitive operations terminate",
        "applies_to": "operationExpr",
        "constraint": "all ops in operationName are total"
      },
      {
        "id": "reserved-upper-snake-case",
        "description": "UPPER_SNAKE_CASE identifiers are reserved for operations",
        "applies_to": "userIdentifier",
        "constraint": "identifiers matching ^[A-Z][A-Z0-9_]*$ cannot be used for variables, functions, constants, or parameters"
      }
    ]
  },
  
  "namingConventions": {
    "description": "Identifier naming conventions for Embeem",
    "operations": {
      "pattern": "^[A-Z][A-Z0-9_]*$",
      "description": "Operations use UPPER_SNAKE_CASE exclusively",
      "examples": ["GPIO_READ", "ADC_SET_RESOLUTION", "DELAY_MS", "I2C_INIT"]
    },
    "userIdentifiers": {
      "pattern": "^(?![A-Z][A-Z0-9_]*$)[a-zA-Z_][a-zA-Z0-9_]*$",
      "description": "User-defined identifiers must not use UPPER_SNAKE_CASE",
      "validExamples": ["x", "myVariable", "my_variable", "MyType", "_private"],
      "invalidExamples": ["GPIO", "MY_CONST", "ADC_CHANNEL"]
    }
  }
}
